var g=Object.defineProperty;var r=(i,t)=>g(i,"name",{value:t,configurable:!0});import{Encrypter as f,useFacade as y,Facade as v,ServiceProvider as w,Validator as k,AuthManager as O,Str as n}from"@lunoxjs/core";import $ from"bcrypt";import{Model as j}from"objection";import{Knex as G}from"knex";var D=Object.defineProperty,q=r((i,t)=>D(i,"name",{value:t,configurable:!0}),"n$2");let b=r(class{model;constructor(t){this.model=t}async updateRememberToken(t,e){const s=t.constructor.timestamps;t.constructor.timestamps=!1,t[t.getRememberTokenName()]=e,await t.save(),t.constructor.timestamps=s}validateCredentials(t,e){return $.compareSync(e.password,t.getAuthPassword())}async retrieveByCredentials(t){if(!t||Object.keys(t).length==1&&Object.keys(t).includes("password"))return;let e=this.model.query();for(const s in t)s.includes("password")||(e=e.where(s,t[s]));return await e.first()}async retrieveById(t){return await this.model.query().where(this.model.idColumn,t).first()}async retrieveByToken(t,e){const s=await this.model.query().where(this.model.idColumn,t).first();if(!s)return;const a=s.getRememberToken();return a&&f.hashEquals(a,e)?s:void 0}},"s");q(b,"EloquentUserProvider");var S=Object.defineProperty,_=r((i,t)=>S(i,"name",{value:t,configurable:!0}),"o$2");class c{app;config={};driver;db;constructor(t){this.app=t}configuration(t=null){if(t=t||this.getDefaultConnection(),this.config[t])return this.config[t];const e=this.app.config.get("database.connections");if(e[t]===null)throw new Error(`Database connection [${t}] not configured.`);return this.config[t]=e[t],e[t]}getDefaultConnection(){return this.app.config.get("database.default")}async bootDriver(){const t=this.getDefaultConnection();if(this.isUsingKnex())this.driver=(await import("knex")).default;else throw new Error(`currently [${t}] database driver not supported`)}async makeConnection(){const t=this.getDefaultConnection(),e=this.configuration(t),s={mysql:"mysql",pgsql:"pg",sqlite:"sqlite3"};this.db=this.driver({client:s[e.driver],connection:{host:e.host,user:e.username,password:e.password,database:e.database,filename:e.database,port:e.port},useNullAsDefault:e.useNullAsDefault??!1,pool:{min:e.pool?.min??0,max:e.pool?.max??10,idleTimeoutMillis:e.pool?.idleTimeoutMillis??500}});try{const{Model:a}=(await import("objection")).default;a.knex(this.db)}catch{}}isUsingKnex(){const t=this.app.config.get("database.connections");return Object.keys(t).some(e=>["mysql","sqlite","pgsql"].includes(e))}get table(){return this.db.table.bind(this.db)}get raw(){return this.db.raw.bind(this.db)}get transaction(){return this.db.transaction.bind(this.db)}getDb(){return this.db}getDriver(){return this.driver}}r(c,"r"),_(c,"DatabaseManager");var P=Object.defineProperty,A=r((i,t)=>P(i,"name",{value:t,configurable:!0}),"e$1");class u extends v{static getFacadeAccessor(){return"db"}}r(u,"t"),A(u,"DB");var o=y(u);const E={name:"unique",passes:async(i,t)=>{if(!i||i.length<2||i.length>4)throw new Error("Invalid rule args, the usage must be unique:table,value,?ignored,?ignoredColumn=id");const[e,s,a,p="id"]=i,h=await o.table(e).where(s,t).first();return a&&h?.[p].toString()==a.toString()?!0:!h}};var x=Object.defineProperty,C=r((i,t)=>x(i,"name",{value:t,configurable:!0}),"o$1");class l extends w{async register(){this.app.singleton("db",()=>new c(this.app))}async boot(){await o.bootDriver(),await o.makeConnection(),k.extend(E),O.registerUserProvider("eloquent",t=>new b(t.model))}}r(l,"i"),C(l,"DatabaseServiceProvider");var I=Object.defineProperty,T=r((i,t)=>I(i,"name",{value:t,configurable:!0}),"c$1");let m=r(class extends j{id;created_at;updated_at;static fillable=[];static guarded=[];static appends=[];static hidden=[];static timestamps=!0;static table="";static primaryKey="id";#s=[];#t=[];attributes={};#i=!1;#e={};constructor(){super(),this.#s=get_class_methods(this).join(";").match(/(?<=(set))(.*?)(?=Attribute)/g)||[],this.#t=get_class_methods(this).join(";").match(/(?<=(get))(.*?)(?=Attribute)/g)||[],[...this.#t,...this.#s].forEach(t=>{const e=n.snake(t);Object.defineProperty(this,e,{get:()=>this.#t.includes(t)?this[`get${t}Attribute`]():this.attributes[e],set:s=>{if(this.#s.includes(t)&&s!==this.attributes[n.snake(t)])return this[`set${t}Attribute`](s);this.attributes[e]=s},enumerable:this.constructor.appends.includes(e),configurable:!0})})}static get tableName(){return this.table}static get idColumn(){return this.primaryKey}static beforeInsert(t){this.filterInput(t.inputItems),this.timestamps&&(this.touchTimeStamps(t.inputItems,"created_at"),this.touchTimeStamps(t.inputItems,"updated_at"))}static beforeUpdate(t){this.filterInput(t.inputItems),this.timestamps&&this.touchTimeStamps(t.inputItems,"updated_at")}$parseDatabaseJson(t){return t=super.$parseDatabaseJson(t),this.#i=!0,this.#e={...t},this.attributes={...t},[...this.#t,...this.#s].map(e=>n.snake(e)).forEach(e=>{Object.keys(this.attributes).includes(e)&&!this.constructor.hidden.includes(e)&&Object.defineProperty(this,e,{enumerable:!0})}),this.attributes}$formatJson(t){return t=super.$formatJson(t),this.#t.forEach(e=>{const s=Object.keys(t.attributes),a=n.snake(e);(this.constructor.appends.includes(a)||s.includes(a))&&(t[a]=this[a])}),delete t.attributes,t}$formatDatabaseJson(t){t=super.$formatDatabaseJson(t),t={...t,...t.attributes};const e=Object.keys(this.#e);if(e.length>0)for(const s in t)e.includes(s)||delete t[s];return delete t.attributes,t}static touchTimeStamps(t,e){t.map(s=>(s[e]=new Date,s))}static filterInput(t){let e=!1;t.map(s=>(Object.keys(s).includes("_isSaveAction")&&(e=s._isSaveAction,delete s._isSaveAction),Object.keys(s).includes("_original")&&(s.setOriginal(s._original),delete s._original),s)),this.fillable.length>0&&!e&&t.map(s=>(Object.keys(s).forEach(a=>{if(a=="attributes")return s;this.fillable.includes(a)||delete s[a]}),s)),this.guarded.length>0&&!e&&t.map(s=>(this.guarded.forEach(a=>{delete s[a]}),s))}async save(){let t={};const e=this.#i?"patch":"insert";return e=="patch"?Object.keys(this.attributes).forEach(s=>{this.#t.includes(n.studly(s))?t[s]=this.attributes[s]:t[s]=this[s]}):(t={...this},Object.keys(t).forEach(s=>{this.#t.includes(n.studly(s))&&delete t[s]}),t={...t,...this.attributes},this.#e={...t},delete this.#e.attributes),t._original=this.#e,t._isSaveAction=!0,await this.$query()[e](t)}getOriginal(){return this.#e}setOriginal(t){this.#e=t}},"n");T(m,"Model");var M=Object.defineProperty,J=r((i,t)=>M(i,"name",{value:t,configurable:!0}),"e");class d{async run(){}async call(t){await new t().run()}}r(d,"n"),J(d,"Seeder");export{o as DB,l as DatabaseServiceProvider,G as Knex,m as Model,d as Seeder};
